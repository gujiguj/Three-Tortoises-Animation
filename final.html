<!DOCTYPE html>
<head>
<title>Final Project</title>
<script src="https://csc4300-fall2021.github.io/lib/three.js"></script>
<script src="https://csc4300-fall2021.github.io/lib/KeyboardState.js"></script>
<script src="https://csc4300-fall2021.github.io/lib/OrbitControls.js"></script>


<script>
    var scene, camera, renderer; // Three.js rendering basics
    var canvas; // The canvas on which the image is rendered


    var shellRadius = 6;
    var legRadius = 1;
    var legLength = 2;
    var headRadius = 1;
    var neckLength = 4;
    var tailRadius = 1;
    var tailLength = 3;
    var tuck = 0.4;

    var big;
    var bigShell; var bigHead; var bigTail;
    var bigLegFL; var bigLegFR; var bigLegBL; var bigLegBR;

    var mid;
    var midShell; var midHead; var midTail;
    var midLegFL; var midLegFR; var midLegBL; var midLegBR;

    var small;
    var smallShell; var smallHead; var smallTail;
    var smallLegFL; var smallLegFR; var smallLegBL; var smallLegBR;

    var mouse;
    var keyboard = new KeyboardState();

    var ambient; var eyeLight; var topLight;
    
    // Use a clock to keep track of time (clock starts automatically)
    var clock = new THREE.Clock();

    // Time at the beginning of animation 
    var startTime = clock.getElapsedTime();

    var keyframesBig = [
        //z-rotations!!!
        //(11) [time stamp, tortoise x, tortoise y, tortoise z-rotation, shell y, head x, head rotation, legFL rotation, legFR rotation, legBL rotation, legBR rotation]
        [0, 0.0, 0.0, 0.0, 0.0, -shellRadius + neckLength + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0],
        [0.4, 0.0, 0.0, 0.0, 0.0, -shellRadius + neckLength + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // right before Small dies
        [0.45, 0.0, 0.0, 0.0, 0.0, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // show head and catch Small
        [0.55, 0.0, 0.0, 0.0, 0.0, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // holding small
        [0.65, 0.0, 0.0, 0.0, legLength, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // standing up
        [0.8, 0.0, 0.0, 0.0, legLength, -shellRadius + tuck, 2.2, 0.0, 0.0, 0.0, 0.0], // tilting head down for small
        [1.0, 0.0, 0.0, 0.0, legLength, -shellRadius + tuck, 2.2, 0.0, 0.0, 0.0, 0.0], // tilting head down for small
    ]; 

    var keyframesMid = [
        //z-rotations!!!
        //(11) [time stamp, tortoise x, tortoise y, tortoise rotation, shell y, head x, head rotation, legFL rotation, legFR rotation, legBL rotation, legBR rotation]
        [0, 0.0, shellRadius, 0.0, 0.0, -shellRadius + neckLength + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0],
        [0.2, 0.0, shellRadius, 0.0, 0.0, -shellRadius + neckLength + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // right before standing up
        [0.25, 0.0, shellRadius, 0.0, legLength, -shellRadius + neckLength + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // standing up quickly, no head
        [0.3, 0.0, shellRadius, 0.0, legLength, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // head comes out quickly
        [0.45, 0.0, shellRadius, 0.0, legLength, -shellRadius + tuck, 3*Math.PI/4, 0.0, 0.0, 0.0, 0.0], // watching Small on Big's head
        [0.55, 0.0, shellRadius, 0.0, legLength, -shellRadius + tuck, 3*Math.PI/4, 0.0, 0.0, 0.0, 0.0], // watching Small on Big's head
        [0.65, 0.0, shellRadius + legLength, 0.0, legLength, -shellRadius + tuck, 3*Math.PI/4, 0.0, 0.0, 0.0, 0.0], // lifted by Big
        [1.0, 0.0, shellRadius + legLength, 0.0, legLength, -shellRadius + tuck, 3*Math.PI/4, 0.0, 0.0, 0.0, 0.0], // lifted by Big
    ];

    var keyframesSmall = [
        //z-rotations!!!
        //(11) [time stamp, tortoise x, tortoise y, tortoise rotation, shell y, head x, head rotation, legFL rotation, legFR rotation, legBL rotation, legBR rotation]
        [0, 0.0, shellRadius*1.5, 0.0, 0.0, -shellRadius + neckLength + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0],
        [0.1, 0.0, shellRadius*1.5, 0.0, legLength, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // standing up and showing head
        [0.2, -(shellRadius/2) * (Math.sqrt(2)/2), (shellRadius/2) * (Math.sqrt(2)/2) + shellRadius, Math.PI/4, legLength, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // walking off Mid
        [0.25, -(shellRadius/2) * (Math.sqrt(2)/2), (shellRadius/2) * (Math.sqrt(2)/2) + shellRadius + (legLength/2), Math.PI/4, legLength, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // Mid gets up
        [0.3, -(shellRadius/2) * (Math.sqrt(2)/2) - 2, (shellRadius/2) * (Math.sqrt(2)/2) + shellRadius + legLength/2 + 2, Math.PI/2, 0.0, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // thrown
        [0.4, -shellRadius - 1, shellRadius, 3*Math.PI/4, 0.0, -shellRadius + neckLength + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // about to die
        [0.45, -shellRadius - 2, headRadius*2 + shellRadius*0.25, Math.PI, 0.0, -shellRadius + neckLength + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // caught by Big
        [0.5, -shellRadius - 2, headRadius*2 + shellRadius*0.25, Math.PI, 0.0, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // remain for a sec
        [0.55, -shellRadius - 2, headRadius*2 + shellRadius*0.25, Math.PI, 0.0, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // head comes out
        [0.65, -shellRadius - 2, headRadius*2 + shellRadius*0.25 + legLength, Math.PI, 0.0, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // lifted by big
        [0.8, -shellRadius - 2, 4.4, Math.PI + 0.64, 0.0, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // rolling off
        [0.85, -shellRadius - 4.5, 2.0, Math.PI + Math.PI/2, 0.0, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // almost rolled off
        [0.9, -shellRadius - 5, 0.0, 2*Math.PI, 0.0, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // head comes out
        [1.0, -shellRadius - 5, 0.0, 2*Math.PI, legLength, -shellRadius + tuck, Math.PI/2, 0.0, 0.0, 0.0, 0.0], // legs come out
    ];

    // TODO Step 5: Copy and paste the code for keyframeInterp here
    // keyframes, duration of one animation cycle (in seconds), time elapsed since beginning of animation
    function keyframeInterp(keyframes, cycleTime, animTime) {

        var keys=[];  // array of interpolated values
        var nKeys = keyframes[0].length-1;  // number of keys = 2

        // find time elapsed within the current cycle and scale to [0,1]
        var time = (animTime % cycleTime) / cycleTime; // what percentage of a cycle has been done already

        // find the next keyframe based on time
        for (var i = 0; i < keyframes.length; i++) {
            if (time < keyframes[i][0]) break;
        }
        i = i-1; // previous keyframe is at index i-1

        // scale interpolation parameter t to interval [0,1]
        var t = (time - keyframes[i][0]) / (keyframes[i+1][0] - keyframes[i][0]); // what percentage t of interpolation between keyframes has been done already

        // linear interpolation between keyframes i and i+1 
        for(var j = 1; j <= nKeys; j++)
            keys.push((1-t) * keyframes[i][j] + t * keyframes[i+1][j]); 

        return keys; // returns list of interpolated rotations
    }

    // Create a camera, sitting on the positive z-axis.  The camera is not part of the scene
    function createCamera() {
        camera = new THREE.PerspectiveCamera(40, canvas.width/canvas.height, 0.1, 500);
        camera.position.set(0,0,40); // change parameters as needed

        mouse = new THREE.OrbitControls(camera, renderer.domElement);
    }

    function createEye(radius) {
        var eye = new THREE.Object3D();

        var eyeMat = new THREE.MeshBasicMaterial( { color: "black" } );
        var eyeGeom = new THREE.SphereGeometry(radius, 32, 32, 0, 2*Math.PI, 0, Math.PI/2);
        var eyeMesh = new THREE.Mesh(eyeGeom, eyeMat);

        eye.add(eyeMesh);

        return eye;
    }

    function createHead(radius, height) {
        // create a cylinder with a rounded edge using a semisphere
        // add small semisphere eyes of 1/8 the radius? 
        // articulation point at flat side of cylinder construct

        // create head container
        // create cylinder container:
            // add cylinder mesh. 
            // add semisphere mesh. position it y = height/2 (at the edge of the cylinder)
            // add right semisphere eye (facing left). position it y = height/2. rotate x -90 deg. position z = -radius
            // add left semisphere eye. position it y = height/2. rotate x +90 deg. position z = radius
        // add cylinder container to head container. position cylinder container y = height/2

        var head = new THREE.Object3D();
        height = height-radius;
        
        var cylinder = new THREE.Object3D();
        var cylinderMat = new THREE.MeshPhongMaterial( { color:"lightgreen" } );
        var cylinderGeom = new THREE.CylinderGeometry(radius, radius, height, 64, 64);
        var cylinderMesh = new THREE.Mesh(cylinderGeom, cylinderMat);
        cylinder.add(cylinderMesh);

        var sphereMat = new THREE.MeshPhongMaterial( { color: "lightgreen" } );
        var sphereGeom = new THREE.SphereGeometry(radius, 32, 32, 0, 2*Math.PI, 0, Math.PI/2 );
        var sphereMesh = new THREE.Mesh(sphereGeom, sphereMat);
        cylinder.add(sphereMesh);
        sphereMesh.position.y = height/2;

        var eyeR = createEye(radius * 0.15);
        cylinder.add(eyeR);
        eyeR.position.y = height/2;
        eyeR.rotation.x = -Math.PI/2;
        eyeR.position.z = -radius;

        var eyeL = createEye(radius * 0.15);
        cylinder.add(eyeL);
        eyeL.position.y = height/2;
        eyeL.rotation.x = Math.PI/2;
        eyeL.position.z = radius;

        head.add(cylinder);
        cylinder.position.y = height/2;

        return head;
    }

    function createLeg(radius, height) {
        // create a cylinder with a rounded edge using a semisphere
        // articulation point at flat side of cylinder construct

        // create leg container
        // create cylinder container:
            // add cylinder mesh. 
            // add semisphere mesh. position it y = height/2 (at the edge of the cylinder)
        // add cylinder container to leg container. position cylinder container y = height/2. rotatez +180

        var leg = new THREE.Object3D();
        
        height = height-radius;

        var cylinder = new THREE.Object3D();
        var cylinderMat = new THREE.MeshPhongMaterial( { color:"lightgreen" } );
        var cylinderGeom = new THREE.CylinderGeometry(radius, radius, height, 64, 64);
        var cylinderMesh = new THREE.Mesh(cylinderGeom, cylinderMat);
        cylinder.add(cylinderMesh);

        var sphereMat = new THREE.MeshPhongMaterial( { color: "lightgreen" } );
        var sphereGeom = new THREE.SphereGeometry(radius, 32, 32, 0, 2*Math.PI, 0, Math.PI/2 );
        var sphereMesh = new THREE.Mesh(sphereGeom, sphereMat);
        cylinder.add(sphereMesh);
        sphereMesh.position.y = height/2;

        leg.add(cylinder);
        cylinder.position.y = height/2;
        cylinder.rotation.z = Math.PI;
        cylinder.position.y -= height;

        return leg;
    }

    function createShell(radius) {
        // create a semisphere 
        // articulation point at bottom (flat side)

        // create shell container
        // add semisphere mesh. position semisphere mesh y = radius. 

        var shell = new THREE.Object3D();

        var shellMat = new THREE.MeshPhongMaterial( { color: "darkgreen" } );
        var shellGeom = new THREE.SphereGeometry(radius, 32, 32, 0, 2*Math.PI, 0, Math.PI/2 );
        var shellMesh = new THREE.Mesh(shellGeom, shellMat);
        shell.add(shellMesh);
        
        var capGeom = new THREE.CircleGeometry(radius, 32);
        var capMat = new THREE.MeshBasicMaterial( { color: "darkgreen" });
        var capMesh = new THREE.Mesh(capGeom, shellMat);
        capMesh.rotation.x = Math.PI / 2;
        shellMesh.add(capMesh);

        console.log("created shell:");
        return shell;
    }

    function createTail(radius, height) {
        // create a cone
        // articulation point at bottom face

        // create tail container
        // add cone mesh. position cone mesh y = height/2

        var tail = new THREE.Object3D();

        var tailMat = new THREE.MeshPhongMaterial( { color: "lightgreen" } );
        var tailGeom = new THREE.ConeGeometry(radius, height, 16, 1, false);
        var tailMesh = new THREE.Mesh(tailGeom, tailMat);
        tail.add(tailMesh);

        tailMesh.position.y = height/2;

        return tail;
    }

    function createTortoise() {
        // combine a head, 4 legs, a shell, and a tail

        // create tortoise container
        
        // create shell
        // add shell. shell gets lifted y + legLength to show legs (legs are independent of shell)

        // add head. rotate z = +90. position y + headRadius. position x = -shellRadius when showing (facing the left) (head is independent of shell)

        // add front left leg. x = -(shellradius * sqrt2)/2. z = +(shellradius * sqrt2)/2 
        // add front right leg. x = -(shellradius * sqrt2)/2. z = -(shellradius * sqrt2)/2
        // add back left leg. x = +(shellradius * sqrt2)/2. z = +(shellradius * sqrt2)/2
        // add back right leg. x = +(shellradius * sqrt2)/2. z = -(shellradius * sqrt2)/2

        // add tail. x = shellradius. rotation z -= 90deg

        var tortoise = new THREE.Object3D();

        var shell = createShell(shellRadius);
        tortoise.add(shell);
        shell.position.y += legLength;

        var head = createHead(headRadius, neckLength);
        shell.add(head);

        head.rotation.z += Math.PI/2;
        head.position.y += headRadius;
        head.position.x -= shellRadius - 0.4;

        var legFL = createLeg(legRadius, legLength);
        var legFR = createLeg(legRadius, legLength);
        var legBL = createLeg(legRadius, legLength);
        var legBR = createLeg(legRadius, legLength);
        tortoise.add(legFL); tortoise.add(legFR); tortoise.add(legBL); tortoise.add(legBR);

        var legDistance = (shellRadius*Math.sqrt(2))/2 - legRadius;

        legFL.position.x -= legDistance;
        legFR.position.x -= legDistance;
        legBL.position.x += legDistance;
        legBR.position.x += legDistance;
        
        legFL.position.y += legLength;
        legFR.position.y += legLength;
        legBL.position.y += legLength;
        legBR.position.y += legLength;

        legFL.position.z += legDistance;
        legFR.position.z -= legDistance;
        legBL.position.z += legDistance;
        legBR.position.z -= legDistance;

        var tail = createTail(tailRadius, tailLength);
        shell.add(tail);

        tail.position.x += shellRadius - 0.4;
        tail.position.y += tailRadius;
        tail.rotation.z -= Math.PI/2;

        return tortoise;
    }

    function createBackground(length, width, height) {

        var background = new THREE.Object3D(); 

        var grassTex = texLoader.load("bg-grass-texture.jpg");
        grassTex.wrapS = THREE.RepeatWrapping;
        grassTex.wrapT = THREE.RepeatWrapping;
        grassTex.repeat.set(2,2);
        var material = new THREE.MeshPhongMaterial({map: grassTex, side: THREE.DoubleSide}); 

        // create ground
        var geom = new THREE.PlaneGeometry(length, width); 
        var ground = new THREE.Mesh( geom, material);
        ground.rotation.x = Math.PI/2;
        background.add(ground);

        /*
        var ballGeom = new THREE.SphereGeometry(3.0, 32, 32, 0, 2*Math.PI, 0, 2*Math.PI );
        var ball = new THREE.Mesh(ballGeom, polkaDotMat);
        ball.position.y += 3;
        background.add(ball);
        */

        return background; 
    }

    // Create the scene. This function is called once, as soon as the page loads.
    // The renderer has already been created before this function is called.
    function createScene() {

        renderer.setClearColor(0); // Set background color (0, or 0x000000, is black)
        scene = new THREE.Scene(); // Create a new scene which we can add objects to

        big = createTortoise();
        bigShell = big.children[0];
        bigHead = bigShell.children[1];
        bigTail = bigShell.children[2];
        bigLegFL = big.children[1];
        bigLegFR = big.children[2];
        bigLegBL = big.children[3];
        bigLegBR = big.children[4];
        scene.add(big);
        bigShell.position.y = 0;
        //bigHead.position.x = -shellRadius + neckLength;
        bigHead.position.x = -shellRadius + 0.4;

        mid = createTortoise();
        midShell = mid.children[0];
        midHead = midShell.children[1];
        midTail = midShell.children[2];
        midLegFL = mid.children[1];
        midLegFR = mid.children[2];
        midLegBL = mid.children[3];
        midLegBR = mid.children[4];
        scene.add(mid);
        mid.scale.set(0.5,0.5,0.5);
        mid.position.y = shellRadius;
        //midShell.position.y -= legLength;
        midHead.position.x = -shellRadius + neckLength + 0.4;

        small = createTortoise();
        smallShell = small.children[0];
        smallHead = smallShell.children[1];
        smallTail = smallShell.children[2];
        smallLegFL = small.children[1];
        smallLegFR = small.children[2];
        smallLegBL = small.children[3];
        smallLegBR = small.children[4];
        scene.add(small);
        small.scale.set(0.25,0.25,0.25);
        small.position.y += shellRadius + shellRadius*0.5;

        /*
        small.position.y = 2.0;
        small.position.x = -shellRadius - 4.5;
        smallHead.position.x = -shellRadius + 0.4;
        smallShell.position.y = 0;
        small.rotation.z = -Math.PI/2;

        midHead.position.x = -shellRadius + 0.4;
        midHead.rotation.z = 3*Math.PI/4;
        mid.position.y = shellRadius + legLength;

        bigShell.position.y = legLength;
        bigHead.position.x = -shellRadius + 0.4;
        bigHead.rotation.z = 2.2
        */
        
        /*
        var background = createBackground(50,50,50);
        scene.add(background);

        var loader = new THREE.CubeTextureLoader();
        var skyBoxTexture = loader.load([
            "skybox-posx.png", //pos-x (right)
            "skybox-negx.png", //neg-x (left)
            "skybox-posy.png", //pos-y (top)
            "skybox-negy.png", //neg-y(bottom)
            "skybox-posz.png", //pos-z (forward)
            "skybox-negz.png" //neg-z (back)
        ]);

        scene.background = skyBoxTexture;
        */
   }

   function createLights()
    {
        // Ambient Light (color, intensity)
        ambient = new THREE.AmbientLight(0x404040, 1); // soft white
        scene.add(ambient);

        // DirectionalLight (color, intensity) in the direction the camera faces
        eyeLight = new THREE.DirectionalLight( "white", 0.7 );   
        eyeLight.position.set(camera.position.x,camera.position.y,camera.position.z);  // camera viewpoint
        scene.add(eyeLight);

        // Dim DirectionalLight (color, intensity) shining from above
        topLight = new THREE.DirectionalLight( "white", 0.3 ); 
        topLight.position.set(0,20,0);
        scene.add( topLight );

        var helper = new THREE.DirectionalLightHelper( topLight, 1 );
        //scene.add( helper );
    }

    function update() {
        keyboard.update();

        if ( keyboard.down("P") ) {
            console.log("front left leg rotation: " + bigLegFL.rotation.z);
            console.log("front right leg rotation: " + bigLegFR.rotation.z);
            console.log("head rotation: " + bigHead.rotation.z);
            console.log("tortoise rotation: " + big.rotation.z);
        }

        if ( keyboard.pressed("up")) {
            bigHead.rotation.z -= 0.05;
        }
        if ( keyboard.pressed("down")) {
            bigHead.rotation.z += 0.05;
        }


        if ( keyboard.pressed("A")) {
            bigLegFL.rotation.z -= 0.05;
        }
        if ( keyboard.pressed("D")) {
            bigLegFL.rotation.z += 0.05;
        }

        if ( keyboard.pressed("Q")) {
            bigLegFR.rotation.z -= 0.05;
        }
        if ( keyboard.pressed("E")) {
            bigLegFR.rotation.z += 0.05;
        }

        if ( keyboard.pressed("left")) {
            bigLegBL.rotation.z -= 0.05;
        }
        if ( keyboard.pressed("right")) {
            bigLegBL.rotation.z += 0.05;
        }

        if ( keyboard.pressed(",")) {
            bigLegBR.rotation.z -= 0.05;
        }
        if ( keyboard.pressed(".")) {
            bigLegBR.rotation.z += 0.05;
        }

        if ( keyboard.pressed("C")) {
            big.rotation.z -= 0.05;
        }
        if ( keyboard.pressed("Z")) {
            big.rotation.z += 0.05;
        }
    } 

    // Render the scene. This is called for each frame of the animation.
    function render() {
        requestAnimationFrame( render );

        // code for things to change here
        var keysBig = keyframeInterp(keyframesBig, 15, clock.getElapsedTime() - startTime);
        var keysMid = keyframeInterp(keyframesMid, 15, clock.getElapsedTime() - startTime);
        var keysSmall = keyframeInterp(keyframesSmall, 15, clock.getElapsedTime() - startTime);

        big.position.x = keysBig[0]; big.position.y = keysBig[1]; big.rotation.z = keysBig[2];
        bigShell.position.y = keysBig[3]; 
        bigHead.position.x = keysBig[4]; bigHead.rotation.z = keysBig[5];
        bigLegFL.rotation.z = keysBig[6]; bigLegFR.rotation.z = keysBig[7];
        bigLegBL.rotation.z = keysBig[8]; bigLegBR.rotation.z = keysBig[9];

        mid.position.x = keysMid[0]; mid.position.y = keysMid[1]; mid.rotation.z = keysMid[2];
        midShell.position.y = keysMid[3]; 
        midHead.position.x = keysMid[4]; midHead.rotation.z = keysMid[5];
        midLegFL.rotation.z = keysMid[6]; midLegFR.rotation.z = keysMid[7];
        midLegBL.rotation.z = keysMid[8]; midLegBR.rotation.z = keysMid[9];

        small.position.x = keysSmall[0]; small.position.y = keysSmall[1]; small.rotation.z = keysSmall[2];
        smallShell.position.y = keysSmall[3]; 
        smallHead.position.x = keysSmall[4]; smallHead.rotation.z = keysSmall[5];
        smallLegFL.rotation.z = keysSmall[6]; smallLegFR.rotation.z = keysSmall[7];
        smallLegBL.rotation.z = keysSmall[8]; smallLegBR.rotation.z = keysSmall[9];

        renderer.render(scene, camera);

        //update();
        mouse.update();
    }

    //----------------------------------------------------------------------------------

    // The main() function is called by the onload event when the document has loaded.
    function main() {
        try {
            canvas = document.getElementById("glcanvas");
            renderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true} );
        }
        catch (e) {
            document.getElementById("canvas-holder").innerHTML = "<h3><b>WebGL is not available.</b><h3>";
            return;
        }
    
        // create camera
        createCamera();
        
        // create scene 
        createScene();

        // create lights
        createLights();

        // render scene
        render();
    }

</script>

</head>
<body onload="main()">
<div id="canvas-holder">
    <canvas id="glcanvas" width="1200" height="600"></canvas>
</div>
</body>
</html>
